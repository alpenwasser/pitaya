% ==============================================================================
%
%                           O S C I L L O S C O P E
%
% ==============================================================================
\chapter{Oscilloscope} % <<< ------------------------------------------------- %
\label{ch:app:gui}
% ---------------------------------------------------------------------------- %

% ==============================================================================
%
%                             W E B S O C K E T S
%
% ==============================================================================
\section{WebSockets} % <<< --------------------------------------------------- %
\label{sec:app:gui:websockets}
% ---------------------------------------------------------------------------- %

WebSockets' final RFC 6455\cite{rfc:6455} was released in December 2011 and is
thus still quite young. It is meant to  compensate the lack of raw UDP and TCP
sockets in  JavaScript which is due  to security threats that  are not further
elaborated here.
WebSockets is located  in the Application Layer of  the OSI model\footnote{For
those not familiar with the OSI model Wikipedia~\ref{wiki:osi} provides a good
overview.}.
Instead  of directly  opening  a  raw WebSocket,  the  handshake  is done  via
HTTP(S). This brings  the benefit of  communicating through the same  ports as
the  browser  (80 or  443)  which  enables the  protocol  to  go through  most
firewalls. Furthermore it greatly simplifies the  handshake for the user (here
being the programmer).
The client sends an upgrade request to the server which then opens a WebSocket
connection.
This allows for a very conventient way to use TCP Sockets without any entirely
new standards.
The section ``1.5  Design Philosophy'' in RFC  6455\cite{rfc:6455} explains it
very well:

``Basically it is intended  to be as close to just exposing  raw TCP to script
as possible given the constraints of the Web.

The only  exception is that WebSockets  adds framing to make  it packet rather
than stream based and to differentiate between binary and text data.
This  differentiation is  very useful  for this  project. Instructions to  the
server are issued  via the text channel  whilst data is sent  back through the
binary  channel, allowing  for very  convenient interfacing  with close  to no
effort.''

So in  short: WebSockets are close-to-raw  TCP sockets whose handle  is shared
through HTTP(S).
JavaScript provides a  interface that makes it really easy  to shove data back
and forth.
As  nearly anything  in  JavaScript  this is  done  using callbacks. There  is
callbacks that  handle connections, messages  and errors. The code  snippet in
\ref{lst:gui:jsws}  gives  some  insight  how  WebSockets  in  JavaScript  are
used. All the details can be read in the Mozilla documentation \cite{moz:ws}.

\begin{tcolorbox}[
        title={
            \refstepcounter{listing}
            Listing \thelisting: JavaScript ``Using WebSockets''
            \label{lst:gui:jsws}
            \addcontentsline{lol}{listing}{\protect\numberline{\thelisting}}
        }
    ]
    \inputminted[
        linenos,
        numbersep=4pt,
        style=solarizedlight,
    ]{javascript}{./code/websockets.js}
\end{tcolorbox}
%>>>
% ==============================================================================
%
%                             S T A T E   T R E E
%
% ==============================================================================
\section{State Tree of Oscilloscope} % <<< ----------------------------------- %
\label{sec:app:gui:state_tree_of_scope}
% ---------------------------------------------------------------------------- %
\begin{tcolorbox}[
        title={
            \refstepcounter{listing}
            \textbf{Listing \thelisting:} The state tree of the scope application
            \label{lst:gui:app_structure}
            \addcontentsline{lol}{listing}{\protect\numberline{\thelisting}Scope State Tree}
        },
        breakable,
        title after break={\textbf{Listing \thelisting (cont.):} The state tree of the scope application},
    ]
    \inputminted[
        linenos,
        numbersep=4pt,
        style=solarizedlight,
    ]{javascript}{./code/statetree.js}
\end{tcolorbox}
%>>>
% ==============================================================================
%
%                             M I T H R I L . J S
%
% ==============================================================================
\section{\code{mithril.js}} % <<< -------------------------------------------- %
\label{sec:app:gui:mithril}
% ---------------------------------------------------------------------------- %

The  official  mithril  webpage   describes  \code{mithril.js}  the  following
way: ``Mithril  is  a modern  client-side  Javascript  framework for  building
Single Page Applications. It's  small (< 8kb gzip), fast  and provides routing
and XHR utilities out of the  box.\cite{mithril:home}'' Mithril, like a lot of
other frameworks such as React, Angular.js  or Vue.js uses a virtual DOM. This
means  that  it does  not  modify  the DOM  the  browser  outlines but  rather
maintains it's  own DOM. When  a new  render call is  issued, the  virtual DOM
calculates all the deltas  that stem from new content and  applies them to the
real  DOM. Like this  mithril.js performantly  calculates the  DOM based  on a
descriptive model. The developer does not  have to manually modify an object's
state but rather has to describe it.

A redraw generally happens when an event is triggered by any input element but
can also be issued manually.
A virtual DOM  consists of many vnodes and  can be mounted on any  node of the
browser's DOM as example \ref{lst:gui:mithrilmount} shows.

\begin{tcolorbox}[
        title={
            \refstepcounter{listing}
            Listing \thelisting: Basic creation and usage of mithril components in JavaScript
            \label{lst:gui:mithrilmount}
            \addcontentsline{lol}{listing}{\protect\numberline{\thelisting}Basic Usage of \code{mithril} Components}
        }
    ]
    \inputminted[
        linenos,
        numbersep=4pt,
        style=solarizedlight,
    ]{javascript}{./code/mithrilmount.js}
\end{tcolorbox}

A component can be mounted on any DOM  node and becomes a vnode in the virtual
DOM. The developer can create new Components by simply creating an object that
holds at least a \textit{view()} function that instantiates new vnodes.
The  new  Component   can  then  be  instantiated  via   the  \textit{m()}  or
\textit{m.mount()} command.
As this section should  only give a base overview on mithril  and is not meant
to be  a manual,  further information  on mithrils features  and usage  can be
obtained on it's webpage~\cite{mithril:home}.
%>>>
% ==============================================================================
%
%                                 W e b G L
%
% ==============================================================================
\section{WebGL} % <<< -------------------------------------------------------- %
\label{sec:app:gui:webgl}
% ---------------------------------------------------------------------------- %

The application uses the canvas DOM  element which provides a direct interface
to WebGL. The user can render vertices to the canvas and even apply shaders or
in the case of  this application simple 2D geometry calls  suffice since it is
essentially only necessary to draw lines.
Via  the canvas  one  can retreive  a  2D Rendering  Context  on which  simple
geometry can be drawn.
In JavaScript this  can be done using the code  in \ref{lst:js2dcontext} which
shows how a single red line can be drawn on the canvas.

\begin{tcolorbox}[
        title={
            \refstepcounter{listing}
            Listing \thelisting: Getting a 2D Rendering Context from a Canvas and Drawing on it in JavaScript
            \label{lst:js2dcontext}
            \addcontentsline{lol}{listing}{\protect\numberline{\thelisting}Drawing on Canvas in JavaScript}
        }
    ]
    \inputminted[
        linenos,
        numbersep=4pt,
        style=solarizedlight,
    ]{javascript}{./code/2dcontext.js}
\end{tcolorbox}

There is also  the possibility to draw rectangles, circles  and much more. All
of  those  elements  can  be  styled easily  via  properties  of  the  context
environment. All  the  functionality  is  documented on  the  mozilla  network
\cite{moz:2dcontext}.

Now something can be drawn on a  canvas once. If this should be done to create
an actually moving  image, those draws to  the canvas have to  happen over and
over again. There is  various possibilities to do that in  JavaScript but only
one  is actualy  performant and  recommended. Instead of  just drawing  to the
canvas over  and over again, it  would be ideal to  only do that before  a new
frame is  pulled from  the framebuffer by  the display. JavaScript  provides a
interface  to  register a  callback  that  is called  before  a  new frame  is
released. This callback will be called with  the same frequency as the display
referesh rate, which nowadays usually is \SI{60}{\hertz}.
To make  sure that callback  will always be executed  it has to  be registered
again after  a callback was issued. The  sample \ref{lst:gui:glcallback} shows
how this is done.

\begin{tcolorbox}[
        title={
            \refstepcounter{listing}
            Listing \thelisting: Usage of the requestAnimationFrame callback in JavaScript
            \label{lst:gui:glcallback}
            \addcontentsline{lol}{listing}{\protect\numberline{\thelisting}Usage of \code{requestAnimationFrame Callback}}
        }
    ]
    \inputminted[
        linenos,
        numbersep=4pt,
        style=solarizedlight,
    ]{javascript}{./code/glcallback.js}
\end{tcolorbox}

This callback  will not affect the  rest of the DOM. Like  that the JavaScript
runtime will  handle the redraws of  the dom performantly whilst  the callback
will render a fluent graph of the data onto just one of the DOM elements.
%>>>
% ==============================================================================
%
%                           W I N D O W   T A B L E
%
% ==============================================================================
\section{FFT Windowing Paramters} % <<< -------------------------------------- %
\label{sec:app:gui:fft_params}
% ---------------------------------------------------------------------------- %

\begin{centering}
    \tabcaption[FFT Windowing Parameters]{%
        FFT windowing parameters, taken from~\cite{gui:meyer}%
    }
    \label{tab:fft_window_params}
    \begin{tabular}{l>{$}c<{$}ScS}
        \toprule
         \parbox[c]{17mm}{Window}                                       &
        {\parbox[c]{26mm}{Scaling Factor for Quasi-Periodical Signals}} &
        {\parbox[c]{24mm}{Attenuation of Largest Side Lobe (\si{\dB})}} &
        {\parbox[c]{22mm}{Number of Lines per Bundle}                 } &
        {\parbox[c]{22mm}{Maximum Error in \mbox{Amplitude} (\si{\dB})}      } \\
        \midrule
        Rectangle     & 1        & 13 & 1 -- 2 & -3.8 \\
        Hanning       & 1/0.5000 & 31 & 3 -- 4 & -1.5 \\
        Hamming       & 1/0.5400 & 41 & 3 -- 4 & -1.6 \\
        Blackman      & 1/0.4200 & 58 & 5 -- 6 & -1.1 \\
        Bartlett      & 1/0.5000 & 26 & 3 -- 4 & -1.9 \\
        Kaiser-Bessel & 1/0.4021 & 67 & 7 -- 8 & -1.0 \\
        Flat-Top      & 1/0.2155 & 67 & 9 -- 10 & 0    \\
        \bottomrule
    \end{tabular}
\end{centering}

%>>>

%>>>
%^^A vim: foldenable foldcolumn=4 foldmethod=marker foldmarker=<<<,>>>
