\chapter{Oscilloscope} % <<< ------------------------------------------------- %
\label{ch:graphical_front_end}
% ---------------------------------------------------------------------------- %

Because the  FPGA and Linux  side are newly  implemented, and because  the new
transmission protocol  is not the same  as the old one,  existing applications
reading data from the STEMlab no longer function. A new front-end is therefore
required. This front-end is  a web application whose  functionality is broadly
modelled on conventional oscilloscopes; therefore, it is generally referred to
as \emph{scope} in this report. This chapter lays out the requirements for the
scope, explains the design choices on  which it is built, summarizes the major
implementation details, and presents the final product.

% ==============================================================================
%
%                          R E Q U I R E M E N T S
%
% ==============================================================================

\section{Requirements} % <<< ------------------------------------------------- %
\label{sec:gui:requirements}
% ---------------------------------------------------------------------------- %

The requirements  for the scope  are partially  defined by a  Java application
from  previous projects~\cite{gut:specky}  whose core  capabilities are  to be
replicated. More functionality  may be added where  sensible and possible. The
main requirements are:
\begin{itemize}\tightlist
    \item Receive data in configurable size over the network.
    \item Display received data both in the time and fequency domain.
    \item Calculate RMS power density in the signal.
    \item Calculate THD of the signal.
\end{itemize}
% >>>

% ==============================================================================
%
%                         D E S I G N   C H O I C E S
%
% ==============================================================================

\section{Design Choices} % <<< ----------------------------------------------- %
\label{sec:gui:design_choices}
% ---------------------------------------------------------------------------- %

There is  a wealth  of programming  languages to  choose from,  with countless
libraries to go  with them. The following sections explain  why JavaScript and
web technologies are used to implement  the graphical user interface (GUI) and
the mathematical functions of the scope. 

for  this  purpose,  a  group   of  programming  languages  are  compared  and
weighed  against each  other in  various aspects;  the results  are summarized
in   table~\ref{tab:gui:language_choices}.  the   general  attributes   listed
in  table~\ref{tab:gui:language_choices}  are   explained  in  the  subsequent
paragraphs to enable the reader to  understand how they apply to our decision.
Due to its  importance, there is an additional section  dedicated to the topic
of networking (Section~\label{subsec:gui:networking}).

\paragraph{Open  Standard:} Since this  is a  university project  meant, among
other things, for educational purposes, it  is crucial to make all source code
available to the public under a flexible license. Thus, it is desirable to use
a  technology which  is independent  of any  one company  and their  corporate
policies  (avoiding vendor  lock-in). Some programming  languages are  managed
openly and accept contributions from the public, others not.

\paragraph{Networking:} The  two criteria  which  the data  transfer needs  to
fulfill are  speed and data integrigy.   Since networking is a  highly complex
topic,  it is  important that  the language  not only  has libraries  for good
networking  protocols, but  that those  libraries are  also easy  to use. More
information on the topic is contained in Section~\ref{subsec:gui:networking}.

\paragraph{Graphics:} An oscilloscope is quite a demanding application when it
comes to graphics; drawing an image stream  which looks fluid to the human eye
on modern  high resolution display  uses a  lot of processing  power. Using an
interface such as  OpenGL which can utilize dedicated graphics  resources on a
computer is therefore necessary.

Additionally, creating a  sensible user interface with  basic drawing commands
such as rectangles  and lines is impractical. Instead, a GUI  toolkit to speed
up the design process is needed.

\paragraph{Prevalence:} Using a  technology which is widespread  makes it more
likely that good tutorials are available. It also facilitates troubleshooting,
since a larger  user base means that  there is a higher chance  of savvy users
being able to provide support if needed.

\paragraph{Ease  of  Development:} Some  solutions   require  large  IDEs  and
unwieldy  toolchains  for   development. Others  can  be  used   with  a  more
lightweight  setup. Since both  team  members come  from  a Linux  background,
the  latter  is preferred. Since  added  complexity  always also  means  added
probability  of errors  and failures,  using leaner  tools also  decreases the
chances of having to fight with  the development tools instead of tackling the
actual challenges which are to be solved.

\paragraph{Ease of Deployment:} This takes into  account how easy or difficult
it is for an end-user to install the scope and get it up and running. Having a
toolchain which allows the effortless creation of stable binaries is important
here.

\paragraph{Familiarity With The Language:} The best  toolkits do not matter if
none of  the involved programmers have  ever used them and  will struggle with
even  the basics  for  a major  part  of the  project's  duration. Thus it  is
inevitable that personal preferences also flow into the decision process.

\begin{table}
    \centering
    \caption[Comparison of Programming Languages]{%
        A comparison  of a few  programming languages  which might be  used to
        implement  a  graphical  front-end  like the  oscilloscope  from  this
        project. The scale goes from \num{1} (worst) to \num{6} (best).%
    }
    \label{tab:gui:language_choices}
    \begin{tabular}{lrrrrr}
        \toprule
                                        & \parbox[t]{2mm}{\rotatebox{90}{Rust}}
                                        & \parbox[t]{2mm}{\rotatebox{90}{C++}}
                                        & \parbox[t]{2mm}{\rotatebox{90}{Java}}
                                        & \parbox[t]{2mm}{\rotatebox{90}{Python}}
                                        & \parbox[t]{2mm}{\rotatebox{90}{JavaScript}}\\
        \midrule
        Open Standard                   &  6 &  6 &  1 &  6 &  6 \\
        Networking                      &  6 &  6 &  6 &  6 &  4 \\
        Graphics                        &  2 &  5 &  5 &  5 &  6 \\
        Prevalence                      &  3 &  6 &  6 &  5 &  6 \\
        Ease of Development             &  5 &  5 &  5 &  5 &  6 \\
        Ease of Deployment              &  3 &  4 &  5 &  6 &  6 \\
        Familiarity With the Language   &  3 &  3 &  4 &  6 &  6 \\
        \midrule
        Total                           & 28 & 35 & 32 & 39 & 40 \\
        \bottomrule
    \end{tabular}
\end{table}

\paragraph{Summary:} As          the          total         scores          in
Table~\ref{tab:gui:language_choices} show, JavaScript  fits the priorities set
in this project best. As  a scripting language which can be  run in any modern
browser, a website  can be provided by  the STEMlab board and  accessed from a
client via  a browser. Since no special  programs need to be  installed on the
client  computer, and  every major  operating system  today has  at least  one
reasonably modern  browser, this makes  the solution both highly  portable and
easy to deploy from an end-user perspective.

JavaScript's  popularity ensures  that there  is no  danger of  the underlying
technology  of  the  scope   becoming  obsolete  any  time  soon. Furthermore,
with  its support  for  WebGL and  the WebSockets  protocol,  it provides  two
performant and easy-to-use technologies  to implement graphics and networking,
respectively. Its primary downside is a heavy memory footprint, but since that
is  rarely a  concern on  modern computers,  it is  not considered  a relevant
factor for our decision.

% >>>

% ==============================================================================
%
%                          N E T W O R K I N G
%
% ==============================================================================

\subsection{Networking} % <<< ------------------------------------------------ %
\label{subsec:gui:networking}
% ---------------------------------------------------------------------------- %

For networking, two primary protocols are available: UDP and TCP.  To ensure a
fluid stream of data, minimizing protocol overhead is key. In situations where
data integrity is not essential, UDP is generally used. It carries no overhead
for guaranteeing completeness and correct order of packages.

If data  integrity is vital, TCP  is generally the protocol  of choice. It has
mechanisms  for  guaranteeing  both  the completeness  and  correct  order  of
packages.  This comes at the cost  of some overhead, but in most applications,
this is negligible and well worth the cost. Another key feature of TCP is that
it can perform congestion control. TCP will  sent no more packages if previous
packages  have  gone missing  (i.e. TODO:  if  their  reception has  not  been
confirmed?).  Where UDP will happily flood the network with as much data as it
is fed,  TCP ensures that  the network is not  flooded. The result is  that in
case of a  bad or slow network  connection, the amount of  transmitted data is
automatically adapted  to the network,  and only as much  data is sent  as the
client can actually receive and process.

When  deciding how  to  deploy TCP,  one  can choose  to  implement one's  own
subprotocol,  or  use  one  of   the  existing  two: HTTP  or  WebSockets. The
WebSockets  subprotocol,   being  intended  for  data   streaming  and  having
mature  JavaScript   support,  fits   the  requirements  of   our  application
perfectly.    Some  additional   notes   on  WebSockets   can   be  found   in
Appendix~\ref{sec:app:gui:websockets} on page~\ref{sec:app:gui:websockets}.

%>>>

% ==============================================================================
%
%                              P R O D U C T
%
% ==============================================================================

\section{Product} % <<< ------------------------------------------------------ %
\label{sec:gui:product}
% ---------------------------------------------------------------------------- %

\begin{figure}
    \centering
    \includegraphics[width=1\textwidth]{images/gui/scope}
    \caption[The scope application]{%
        The scope application in it's current state, displaying time and FFT data.%
    }
    \label{fig:gui:screenshot}
\end{figure}

The oscilloscope  is a web  application that can  be directly loaded  from the
server  running on  the  STEMlab. It  has the  following  capabilities in  its
current implementation:
\begin{itemize}\tightlist
    \item 
        Receive data over  the network for two channels (this  is only limited
        by the physical channels of the STEMlab).
    \item 
        Manage triggering set a trigger type,  level and the number of samples
        that have to be recorded before and after the trigger is activated.
    \item 
        Calculate and display the power density spectrum.
    \item 
        Calculate the SNR both automatically detecting the signal and manually
        being told where the signal is.
    \item 
        Calculate the THD for a given base harmonic. TODO: !
    \item 
        Export data to an array-string.
    \item 
        Export and load the scope configuration to and from JSON strings.
\end{itemize}
The  following  pages  explain  how   the  application  is  structured,  along
with  the  implementation  of  some  of  its  key  features. A  screenshot  in
Figure~\ref{fig:gui:screenshot}  shows the  overall layout  and design  of the
scope.


% ==============================================================================
%
%                  A P P L I C A T I O N   S T R U C T U R E
%
% ==============================================================================

\subsection{Application Structure} % <<< ------------------------------------- %
\label{subsec:gui:application_structure}
% ---------------------------------------------------------------------------- %


The  entire   application  consists  of   a  single  state   tree. This  makes
it  very   easy  to  import  and   export  settings  and  presents   a  better
overview  of   the  application   state  than  scattering   state  information
across   various   objects.   Listing~\ref{lst:gui:app_structure}   shows   an
extract  of   the  tree   structure. Like  any  JavaScript   application,  the
oscilloscope  runs   asynchronously. Its  eventloop  structure  is   shown  in
Figure~\ref{fig:gui:eventstructure}.

\begin{figure}
    \centering
    \input{images/gui/eventloop.tikz}
    \caption[Scope Event Structure]{%
        The scope's event structure
    }
    \label{fig:gui:eventstructure}
\end{figure}

\begin{tcolorbox}[
        title={
            \refstepcounter{listing}
            \textbf{Listing \thelisting:} The state tree of the scope application
            \label{lst:gui:app_structure}
            \addcontentsline{lol}{listing}{\protect\numberline{\thelisting}Scope State Tree}
        },
        breakable,
        title after break={\textbf{Listing \thelisting (cont.):} The state tree of the scope application},
    ]
    \inputminted[
        linenos,
        numbersep=4pt,
        style=solarizedlight,
    ]{javascript}{./code/statetree.js}
\end{tcolorbox}

All of the values  that can be controlled through the GUI --  and many more --
are  also controllable  directly through  the state  tree. Upon initialization
of  the  application, the  entire  state  tree  is  loaded and  references  to
parts  of it  are passed  to  the controller  objects.  The  structure of  the
application  is hierarchical;  the most  important relations  are depicted  in
Figure~\ref{fig:gui:structure}.  In  the following some of  the more important
prototypes  and functions  from Figure~\ref{fig:gui:structure}  are elaborated
upon.

\begin{figure}
    \centering
    \input{images/gui/structure.tikz}
    \caption[The scope structure]{%
        The structure of the scope application with its major relations%
    }
    \label{fig:gui:structure}
\end{figure}

% ==============================================================================
%
%                                  N O D E S
%
% ==============================================================================

\paragraph{The  \code{Oscilloscope} prototype}  is  the  top level  controller
which contains  exactly one source. It  is responsible for handling  all mouse
events  and  reacting  accordingly,  such  as  moving  the  trigger  level  or
zooming and  panning.  The Oscilloscope  draw call is responsible  for drawing
general information  which is not  part of a  specific trace onto  the canvas.
\code{Oscilloscope}  is  also  the  caller for  the  \code{Trace}  \code{draw}
call. \code{Oscilloscope}  manages general information and  is responsible for
rescaling the canvas and initiating the draw call chain.

\paragraph{The  \code{Source}  controller}  manages  all  calls  to  and  from
the  server. It  contains  a  lot  of   helper  calls  to  set  a  trigger  or
issue  a  new  frame. Those  helpers are  called  by  the  \code{Oscilloscope}
controller or GUI elements.  It also  contains the important callbacks to send
and  receive data  from  the  server. They are  explained  in  more detail  in
Appendix~\ref{sec:app:gui:websockets}.

\code{Source} stores all received frames in itself. The frames will then later
be  copied and  processed by  the trace  controller.  Each  frame received  is
always overwritten by the next one,  preventing memory leaks and ensuring that
the data is current.

Once  the   \code{Source}  controller  receives   new  data,  it   starts  the
\code{calc()} call for each  trace to trigger an update of  the trace with new
data.

\paragraph{The \code{Trace} prototype} is in charge of displaying the recorded
and calculated  data in the  scope application.   The trace controller  can be
managing an FFT or a normal time trace. This could be extended to general math
traces, e.g. subtracting two differential pair traces for noise cancelling, in
the future.  Each  derived trace prototype calculates some metrics  and a grid
to quantize the signal.

Whilst  the  \code{Timetrace}  prototype  just  returns  untouched  data,  the
\code{FFTrace} prototype calculates metrics. Namely those are:
\begin{itemize}\tightlist
    \item The spectral power density
    \item The SNR
    \item The THD TODO: !
\end{itemize}

The graphics portion of the scope application is the most important part for a
nice to use  interface. Since the scope application should plot  data fast and
conveniently  as  well  as  display  some  numbers  and  provide  controls  to
manipulate the view, it is important to  have a good library, that enables the
coder to do all  those things. It is absolutely key to  render the graphics on
the  GPU. Since the  application should  be  cross platform  and open  source,
libraries using OpenGL  is a good choice. Since JavaScript  exposes WebGL this
is a perfect match.

With the choice of JavaScript \& HTML  there comes a great wealth of libraries
that enable the user to easily write GUI applications. Prototyping is fast and
with CSS and a lot of different frameworks the GUI is also nice-looking.

A  few frameworks  were evaluated  to build  the controls  of the  scope, with
mithril.js finally  being chosen for it's  simplicity and flexibility. Mithril
is a framework with an exceptionally low footprint and high DOM recalculation.
Those two facts are key to a good  WebUI, since the User does not want to load
lots of data and also does not  want to experience any lag when refreshing the
UI.
More on mithril.js in section \ref{subsec:gui:mithril}.

To plot the  data some graphing libs could have  been used. Those would namely
be plotly.js or chart.js. Whilst they bring in a lot of built in functionality
like logarithmic  plots or  automatic axis  labeling, they  also have  a quite
heavy overhead.
Practical experience and tests have shown that  both of them are not meant and
performant enough to plot high amounts of data in real time.
Thus it was decided to use WebGL draw calls to draw onto a HTML canvas. A HTML
canvas is  an environment that  is exposed directly from  the GPU to  the user
such that they can use GPU rendering inside the browser.
More on WebGL and it's functioning in the next Section~\ref{subsec:gui:webgl}

% ==============================================================================
%
%                                  W E B G L
%
% ==============================================================================

\subsubsection{WebGL}
\label{subsec:gui:webgl}

The application uses the canvas DOM  element which provides a direct interface
to WebGL. The user can render vertices to the canvas and even apply shaders or
in the case of  this application simple 2D geometry calls  suffice since it is
essentially only necessary to draw lines.
Via  the canvas  one  can retreive  a  2D Rendering  Context  on which  simple
geometry can be drawn.
In JavaScript this  can be done using the code  in \ref{lst:js2dcontext} which
shows how a single red line can be drawn on the canvas.

\begin{tcolorbox}[
        title={
            \refstepcounter{listing}
            Listing \thelisting: Getting a 2D Rendering Context from a Canvas and Drawing on it in JavaScript
            \label{lst:js2dcontext}
            \addcontentsline{lol}{listing}{\protect\numberline{\thelisting}Drawing on Canvas in JavaScript}
        }
    ]
    \inputminted[
        linenos,
        numbersep=4pt,
        style=solarizedlight,
    ]{javascript}{./code/2dcontext.js}
\end{tcolorbox}

There is also  the possibility to draw rectangles, circles  and much more. All
of  those  elements  can  be  styled easily  via  properties  of  the  context
environment. All  the  functionality  is  documented on  the  mozilla  network
\cite{moz:2dcontext}.

Now something can be drawn on a  canvas once. If this should be done to create
an actually moving  image, those draws to  the canvas have to  happen over and
over again. There is  various possibilities to do that in  JavaScript but only
one  is actualy  performant and  recommended. Instead of  just drawing  to the
canvas over  and over again, it  would be ideal to  only do that before  a new
frame is  pulled from  the framebuffer by  the display. JavaScript  provides a
interface  to  register a  callback  that  is called  before  a  new frame  is
released. This callback will be called with  the same frequency as the display
referesh rate, which nowadays usually is \SI{60}{\hertz}.
To make  sure that callback  will always be executed  it has to  be registered
again after  a callback was issued. The  sample \ref{lst:gui:glcallback} shows
how this is done.

\begin{tcolorbox}[
        title={
            \refstepcounter{listing}
            Listing \thelisting: Usage of the requestAnimationFrame callback in JavaScript
            \label{lst:gui:glcallback}
            \addcontentsline{lol}{listing}{\protect\numberline{\thelisting}Usage of \code{requestAnimationFrame Callback}}
        }
    ]
    \inputminted[
        linenos,
        numbersep=4pt,
        style=solarizedlight,
    ]{javascript}{./code/glcallback.js}
\end{tcolorbox}

This callback  will not affect the  rest of the DOM. Like  that the JavaScript
runtime will  handle the redraws of  the dom performantly whilst  the callback
will render a fluent graph of the data onto just one of the DOM elements.

\subsubsection{PrefPanes}

For each trace an instance of a PrefPane component corresponding to a trace is
created. A PrefPane component is a mithril component that creates a vnode that
exposes all the necessary controls for it's corresponding trace in the GUI.
It is also responsible for displaying calculated  data for a trace such as the
SNR for a FFTrace.
There  is also  a  general  PrefPane that  exposes  general  controls such  as
switching modes, the trigger trace or the active trace.
The  PrefPanes are  built  with mithril.js  which is  introduced  in the  next
section.

\subsubsection{mithril.js}
\label{subsec:gui:mithril}

The official mithril webpage describes mithril.js the following way: ``Mithril
is  a  modern  client-side  Javascript  framework  for  building  Single  Page
Applications. It's  small (<  8kb gzip),  fast  and provides  routing and  XHR
utilities out  of the box.\cite{mithril:home}''  Mithril, like a lot  of other
frameworks such as React, Angular.js or  Vue.js uses a virtual DOM. This means
that it does not modify the DOM the browser outlines but rather maintains it's
own DOM. When a new render call is  issued, the virtual DOM calculates all the
deltas that stem from new content and  applies them to the real DOM. Like this
mithril.js performantly calculates  the DOM based on  a descriptive model. The
developer does not have to manually modify an object's state but rather has to
describe it.

A redraw generally happens when an event is triggered by any input element but
can also be issued manually.
A virtual DOM  consists of many vnodes and  can be mounted on any  node of the
browser's DOM as example \ref{lst:gui:mithrilmount} shows.

\begin{tcolorbox}[
        title={
            \refstepcounter{listing}
            Listing \thelisting: Basic creation and usage of mithril components in JavaScript
            \label{lst:gui:mithrilmount}
            \addcontentsline{lol}{listing}{\protect\numberline{\thelisting}Basic Usage of \code{mithril} Components}
        }
    ]
    \inputminted[
        linenos,
        numbersep=4pt,
        style=solarizedlight,
    ]{javascript}{./code/mithrilmount.js}
\end{tcolorbox}

A component can be mounted on any DOM  node and becomes a vnode in the virtual
DOM. The developer can create new Components by simply creating an object that
holds at least a \textit{view()} function that instantiates new vnodes.
The  new  Component   can  then  be  instantiated  via   the  \textit{m()}  or
\textit{m.mount()} command.
As this section should  only give a base overview on mithril  and is not meant
to be  a manual,  further information  on mithrils features  and usage  can be
obtained on it's webpage~\cite{mithril:home}.

\subsection{Power Calculation}

The scope application calculates the power in the spectrum.

This is  done using the FFT  algorithm developped by Cooley  \& Tukey. The FFT
code  that was  used  is provided  by  Kevin Kwok  \cite{kwok}. It  is a  very
compact  and fast  version  written  in JavaScript  and  free of  charge. It's
functionality has been  proven by matching it against Matlabs  own FFT as seen
in Figure~\ref{fig:gui:fft_comparison}. There  is minor  numerical differences
but that boils down to implementation choices and precision.

\begin{figure}
    \centering
    \input{images/gui/fft_comparison.tikz}
    \caption[FFT comparison]{%
        The used JS FFT compared to the FFT of Matlab.%
    }
    \label{fig:gui:fft_comparison}
\end{figure}

For an input signal $x$ we obtain the spectrum with

\begin{equation}
    Y[i] = \frac{1}{N}FFT\{x[i]w[i]\}
    \label{eq:gui:onesidedf}
\end{equation}

The one-sided power spectrum is not far away and we find it with

\begin{equation}
    P_{yy}[0] = \frac{Y[0]\cdot Y[0]^*}{NG} and P_{yy}[i] = 2\cdot\frac{Y[i]\cdot Y[i]^*}{NG} for 0 < i <= N / 2
    \label{eq:gui:onesidedp}
\end{equation}

The  power  between  two  frequency  can be  found  by  integrationg  all  the
frequencies or in this case summing all the bins

\begin{equation}
    P_{1,2} = \int_{f1}^{f2} P'_{yy}(f)df \approx \sum_{i_1}^{i_2}P_{yy}[i]
    \label{eq:gui:power}
\end{equation}

The noise gain (NG) can be extracted from the Table~\ref{tbl:gui:corrfactors}.

\begin{table}
    \centering
    \begin{tabular}{lSS}
    \toprule
    Window & {CG} & {NG}\\
    \midrule
    Rectangular & 1 & 1\\
    Hamming & 0.54 & 0.3974\\
    Hanning & 0.5 & 0.375\\
    Blackman-Harris & 0.3587 & 0.258\\
    Flat Top & 0.2156 & 0.1752\\
    \bottomrule
    \end{tabular}
\caption{Correction factors for the different window types used in the scope application as seen in \cite{gui:hanspi}.}
\label{tbl:gui:corrfactors}
\end{table}

The exact reasoning behind the math can be read in \ref{gui:hanspi}.

\subsection{SNR Autodetection}

The  SNR   Autodetection  can  be   done  in   a  static  approach   based  on
Section~4.4.3~of~\cite{gui:meyer} and especially  Table~4.3. The basic idea is
to find  the peak  in the  spectrum which  normally is  the signal  and regard
it  and the  $\frac{n}{2}$  spectral  lines before  and  after  as the  actual
signal. The number $n$ is determined using Table~4.3~in~\cite{gui:meyer}.
The rest  of the spectrum is  regarded as noise  except for the DC  offset and
it's next $\frac{n}{2}$ spectral lines.

The SNR can be calculated with

\begin{equation}
    SNR = 10log_{10}(\frac{P_s}{P_n})
    \label{eq:gui:power}
\end{equation}

During  tests only  an  average SNR  of  \textasciitilde\SI{33}{\dB} could  be
measured in the given signal with  the Matlab built in function \textit{snr()}
consistently finding an SNR of 78dB and more for the same signal.
Accounting for  the harmonics  cancellation the Matlab  function has,  our SNR
would still only be \textasciitilde\SI{43}{\dB} with 10 harmonics cancelled.

A second approach to auto-determining the  SNR, is to iteratively increase the
number of lines beneath the peak that  are still considered signal and do this
until the SNR does not change drastically anymore.
In  our  implementation  the  change   is  considered  irrelevant  when  below
\SI{0.05}{\dB} which leads us to the following algorithm:

\begin{algorithm}
    \centering
    \begin{algorithmic}
    \State $l\gets 1$
    \State $max_i\gets 0$
    \State $SNR_p\gets 0$
    \State $SNR_n\gets 0$
    \While{$|SNR_p - nextSNR| > 0.05$}
        \State $SNR_p\gets SNR_n$

        \State $Ps\gets power(spectrum[max_i - l:max_i + l + 1])$

        \State $Pn\gets power([l:max_i - l] + power(spectrum[max_i + l + 1:]$

        \State $SNR_n\gets 10\cdot log_{10}\Bigg(\frac{P_s}{P_n}\Bigg)$
        \State $l\gets l + 1$
    \EndWhile
    \State $SNR\gets SNR_p$
    \end{algorithmic}
    \caption{An algorithm to iteratively determine the SNR of a spectrum.}
    \label{alg:gui:snr}
\end{algorithm}

The algorithm in \ref{alg:gui:snr} can be repeated for any number of harmonics
to cancel them out.

\begin{figure}
    \centering
    \input{images/gui/snr_comparison.tikz}
    \caption[SNR comparison]{%
        The iterative and static SNR detection compared.%
    }
    \label{fig:gui:snr_comparison}
\end{figure}

\subsection{THD Calculation}

TODO: how do we calculate THD

% >>>


% >>>

%^^A vim: foldenable foldcolumn=4 foldmethod=marker foldmarker=<<<,>>>
