\RequirePackage{snapshot}
\documentclass[a4paper,oneside]{alpenthesis/alpenthesis}
% <<< Preamble
\hexfalse
\paperfalse
%https://tex.stackexchange.com/a/210456/131649
\renewcommand\partnumberlinebox[2]{#2\hspace{2em}}
\usetikzlibrary{positioning}
\usepackage{multirow,array}
\tcbuselibrary{breakable}
\tcbset{shield externalize}
\makeindex
% >>>
\begin{document}
\begin{titlingpage} % <<<
    \fullhexpage{q1}{q0}
    \flushright\sffamily

    \vspace*{5em}
    \Huge\bfseries{Red Pitaya}\\[1ex]
    \Large\mdseries{Thesis}\\[3ex]

    \normalsize\mdseries
    
    \vfill
    Raphael Frey\\
    Noah H\"usser\\[3ex]

    \vspace{5em}

    \today\\
    Version 0.0.1
\end{titlingpage} % >>>

\frontmatter % <<<
% https://en.wikipedia.org/wiki/Edition_notice
\tableofcontents*
\clearpage
\listoffigures*
\clearpage
\listoftables*
\clearpage
\listoflistings
\clearpage
% >>>

\mainmatter

\chapter{Introduction} % <<< ------------------------------------------------- %
\label{ch:intro}
% ---------------------------------------------------------------------------- %

\include{chunks/introduction}

\begin{itemize}\firmlist
    \item Rationale (Why?)
    \item What is the general approach to solve this problem?
    \item What has been done so far?
    \item Results of previous work
    \item What are we going to do?
    \item What are the contents of this report?
\end{itemize}

\cite{1163535}

% >>>

\chapter{Theoretical Background} % <<< --------------------------------------- %
\label{ch:analog-to-digital_data_aquisition}
% ---------------------------------------------------------------------------- %

\section{Analog-to-Digital Data Acquisition}
\label{sec:adc-acquisition}

\subsection{The DSP Chain}
\label{subsec:dsp-chain}

Digitally acquiring a signal generally requires at least the following steps:

\begin{itemize}\tightlist
    \item
        Analog LP: Remove any frequencies above fs/2, to enable correct processing
        down the chain (more on this later).
    \item
        ADC: convert time-continuous and value-continuous into value-discreet and
        time-discreet signal. Being value-discreet is of less importance in our
        system, but let it be mentioned that this is the source of the quantization
        noise. Being time-discreet has a few more consequences:
        \begin{itemize}\tightlist
                \item
                    multiplication w/ dirac pulse sequence in time domain
                \item
                    convolution w/ dirac pulse sequence in frequency domain
                \item
                    spectrum of signal is repeated at intervals of fs, centered
                    around each multiple of fs.
                \item
                    if the signal has frequency components above fs/2, this means
                    that different copies of the signal's spectrum will overlap
                    and lead to an error called aliasing. This means that the
                    analog waveform can no longer be unambiguously reconstructed
                    and correct processing of the data down the chain is not possible.
                    The phenomenon called "folding back" is also a consequence of
                    this and will be described in more detail later, because it is
                    of particular importance for our system.
                \item
                    As a consequences, the analog low-pass filter is required.
        \end{itemize}
    \item
        DSP: Can be n inalmost arbitrary. Preferred to analog signal processing because
        it can be done with computers, which are well understood and cheap.
        Primary problem tends to be the amount of data being shoved into the DSP
        system, which is usually constrained with regards to its available resources
        (i.e. processing power). If the ADC provides too much data for the DSP to
        meaningfully process (keep in mind: depending on \emph{what} is to be done
        in the DSP part, sometimes the ADC's data rate might be too high, other times
        not, so it is usually not possible to perfectly match the ADC's specifications
        to the DSP unless the application's scope is very narrowly defined before the
        system is designed).
\end{itemize}

The solution to the problem of too much data is usually downsampling. One could run
the ADC at lower clock frequencies, but oversampling carries some advantages which would
be lost with that.

\subsection{Challenges in Downsampling}
\label{subsec:downsampling}

The most obvious way to downsample from a sequence of values is of course to simply pick
each nth sample. However, this has some serious drawbacks which make it an unworkable solution
in most cases.

\textbf{Fancy Graphics of downsampling without LP filter with explanations}


\subsection{Digital Low-Pass Filters}
\label{subsec:digital-lp-filters}

The obvious solution to this predicament is to apply a (digital) low-pass filter to the
sequence of values before downsampling. For this purpose, three types of filters are commonly
used, each with their own specific advantages and drawbacks: IIR, FIR, CIC.

For theseandthose reasons, we will use FIR and CIC in our system.

\textbf{Fancy graphics of LP filter, downsampling and folding back}

\section{Designing a Filter System}
\label{sec:designing-a-filter-system}

Talking about which type of filter has which properties is all good and well in theory, but
how does one actually apply this knowledge to a practical problem? This section answers that
question insofar as it applies to our project.

\begin{itemize}\tightlist
    \item
        limited HW resources
    \item
        single-stage vs. multi-stage
    \item
        TBW issue with multi-stage
    \item
        filters at lower frequencies use fewer resources
    \item
        halfband filtres
    \item
        CIC: compensation filters
\end{itemize}


%>>>

%\part{System Overview} % <<< ------------------------------------------------- %
%\label{part:System_Overview}
%% ---------------------------------------------------------------------------- %
%
%Fundamental question  to answer in  this part:  \emph{What is our  system, and
%what is it good for?}
%
%This information could also go into \emph{Introduction}?
%
%Provide supplementary theoretical background as needed.
%
%
%\chapter{Analog-to-Digital Data Acquisition} % <<< --------------------------- %
%\label{ch:analog-to-digital_data_aquisition}
%% ---------------------------------------------------------------------------- %
%
%\begin{itemize}
%    \item
%    Generic Chapter on some of the basic principles of AD data processing
%    \item
%    Sampling:
%        \begin{itemize}
%            \item
%            \index{Sampling} in time domain: Multiplication with dirac pulse sequence
%            \item
%            Frequency doman: Convolution of signal spectrum and dirac pulse spectrum
%            \item
%            ``What is spectrum of dirac pulse sequence?'' (dirac pulse sequence)
%            \item
%            Consequently: \index{Spectrum} of sampled signal is repeated for each dirac pulse in the spectrum
%            \item
%            \textbf{Make sure to get distances between pulses as well as heights correct!}
%            \item
%            \index{Aliasing}
%            \item
%            LP-Filtering (Anti-Aliasing Filter)
%            \item
%            Potentially mention reconstruction
%        \end{itemize}
%    \item 
%    Very brief mention of aliasing, low-pass filtering and all that
%    \item
%    Oversampling and Downsampling
%    \item
%    Oversampling: Explain advantage w/r to SNR
%    \item
%    Fancy graphics from Mr. Gut
%    \item
%    How does the Red Pitaya fit into this?
%    \item
%    CIC and FIR filters:
%        \begin{itemize}
%            \item
%            Overview (emphasis on CIC)
%            \item
%            Where to use which, and why?
%            \item
%            Table/Matrix with advantages and drawbacks for each
%            \item
%            How does this translate to our system/Why is this important for us?
%        \end{itemize}
%\end{itemize}
%
%Explain processing chain (do we even have an analog LP filter here?)
%
%\includegraphics[width=0.75\textwidth]{images/dsvChain}
%
%\begin{tikzpicture}[
%        every node/.style={draw}
%    ]
%    \node (analog) at (0,0) {Analog Signal};
%    \node[right=of analog] (lpf) {analog LP filter};
%    \node[right=of lpf] (sampling1) {oversampling};
%    \node[right=of sampling1] (lpf2) {digital LP filter};
%    \node[below=of lpf2] (downsampling) {downsampling};
%    \node[left=of downsampling] (addf) {additional Filtering};
%    \node[left=of addf] (digital) {digital output signal};
%
%    \draw[->] (analog) -- (lpf);
%    \draw[->] (lpf) -- (sampling1);
%    \draw[->] (sampling1) -- (lpf2);
%    \draw[->] (lpf2) -- (downsampling);
%    \draw[->] (downsampling) -- (addf);
%    \draw[->] (addf) -- (digital);
%\end{tikzpicture}
%
%% >>>
%
%\chapter{The Red Pitaya Platform} % <<< -------------------------------------- %
%\label{ch:the_red_pitaya_platform}
%% ---------------------------------------------------------------------------- %
%\section{General Information}
%General Info about Red Pitaya Project:
%\begin{itemize}\firmlist
%    \item How is the PITA project structured? (logically, license-wise, philosophically)
%    \item Why do we care about this?
%    \item Replacement for scopes (motivation: Why would one use the PITA?)
%\end{itemize}
%\subsection{FPGA}
%\subsection{Linux}
%
%\section{Performance and Possible Improvements}
%\begin{itemize}
%    \item
%    What is the stock solution for downsampling and such? Performance?
%    \item
%    Results of Previous Work
%    \item
%    Consequences for us: Possible paths forward
%    \item
%    System Analysis
%    \item 
%    Decision Matrix \& Decision
%    \item
%    pgfplots: Ternary diagram?
%\end{itemize}
%
%% >>>
%
%% >>>

\part{Implementation} % <<< -------------------------------------------------- %
\label{part:Implementation}
% ---------------------------------------------------------------------------- %
Implementation can be read independently of previous part, but there should be
a  red thread  from decision  to \index{implementation}. Deals  primarily with
design decisions.

Present a diagram with all  system components. Then document the components in
their respective chapters and sections.

\chapter{Data Acquisition System}
\label{ch:data_acquisition_system}
\section{FPGA}
\section{Kernel Module}

\chapter{Filters} % <<< ------------------------------------------------------ %
\label{ch:filters}
% ---------------------------------------------------------------------------- %

% >>>

\chapter{Server} % <<< ------------------------------------------------------- %
\label{ch:server}
% ---------------------------------------------------------------------------- %

% >>>

\chapter{Graphical Front End} % <<< ------------------------------------------ %
\label{ch:graphical_front_end}

\input{chunks/gui.tex}

% >>>

% >>>

\part{Developer Guide} % <<< -------------------------------------------------- %
\label{part:Developer_Guide}
% ---------------------------------------------------------------------------- %
Documentation for a person who wishes to utilize our system in their work and/or
improve upon it?

Make sure  to distinguish  between \emph{Implementation} and  this part. Lines
seem a bit blurry to me (R.F.) at the moment (\today).

\chapter{Project Structure} % <<< -------------------------------------------- %
\label{ch:Project_Structure}
% ---------------------------------------------------------------------------- %
Structure of the repository. What can be found where, and what to do with it?

% >>>

\chapter{IP Core} % <<< ------------------------------------------------------ %
\label{ch:IP_Core}
% ---------------------------------------------------------------------------- %
Documentation of our FPGA Project (structure, interfaces, registers \ldots)

% >>>

\chapter{Linux} % <<< -------------------------------------------------------- %
\label{ch:Linux}
% ---------------------------------------------------------------------------- %

Kernel module, server

% >>>

\chapter{Tool Chain} % <<< --------------------------------------------------- %
\label{ch:Tool_Chain}
% ---------------------------------------------------------------------------- %
Vivado, Build Box, ARM Linux, TCL, Makefiles, Libs for building server application

% >>>

% >>>

\part{User Guide} % <<< ------------------------------------------------------ %
\label{part:User_Guide}
% ---------------------------------------------------------------------------- %
Documentation  for the  end user. Primarily  concerned with  the \index{scope}
front-end.

% >>>

\cleardoublepage % <<< ---------------------------------------------APPENDICES %
\begin{titlingpage*}
    \fullhexpage{da2}{ct4}
    \begin{vplace}
        \flushright\Huge\bfseries\sffamily\appendixpagename
    \end{vplace}
\end{titlingpage*}
\appendix
\chapterstyle{alpenappendix}
% ---------------------------------------------------------------------------- %

% Matlab-prettifier: Uses the lstlisting counter
% Minted: Uses the listing counter

\chapter{Code Listings}
\label{ch:Code_Listings}

Shell commands can be type thusly:
\begin{commandshell}
    user:> if [ -f "${myfile}" ];then echo "${myfile} exists!"
\end{commandshell}

\section{Makefile}
\begin{tcolorbox}[
        breakable,
        title={
            \refstepcounter{listing}
            Listing \thelisting: Makefile Code
            \label{lst:makefile}
            \addcontentsline{lol}{listing}{\protect\numberline{\thelisting}Makefile Code}
        }
    ]
    \inputminted{makefile}{code/Makefile}
\end{tcolorbox}

\section{Verilog}
\begin{tcolorbox}[
        breakable,
        width=1.2\textwidth,
        title={
            \refstepcounter{listing}
            Listing \thelisting: Verilog Code
            \label{lst:makefile}
            \addcontentsline{lol}{listing}{\protect\numberline{\thelisting}Verilog Code}
        }
    ]
\inputminted{verilog}{./code/axi_axis_reader.v}
\end{tcolorbox}

\section{VHDL}
\inputminted{vhdl}{./code/comparator.vhd}

\section{TCL}
\inputminted{tcl}{./code/create_cores.tcl}

\begin{listing}
    \begin{minted}[autogobble]{vhdl}
        entity comparator is
            generic (
                Width : integer := 14
            );
            port (
                AxDI : in unsigned(Width - 1 downto 0);
                BxDI : in unsigned(Width - 1 downto 0);
                GreaterxSO : out std_logic;
                EqualxSO : out std_logic;
                LowerxSO : out std_logic
            );
        end comparator;
    \end{minted}
    \caption{Comparator}
    \label{lst:vhdl:comparator}
\end{listing}

\section{Matlab}
Here, we shall also demonstrate breaking a code file into multiple segments
to comment on its contents.

We start with the header:
\begin{tcolorbox}[
        skin = octoboxfirst,
        title={
            \refstepcounter{listing}
            Listing \thelisting: Matlab Code
            \label{lst:makefile}
            \addcontentsline{lol}{listing}{\protect\numberline{\thelisting}Matlab Code}
        }
    ]
    \inputminted[
        linenos,
        numbersep=4pt,
        style=solarizedlight,
        firstline=1,
        lastline=12,
    ]{matlab}{./code/filterChainDesigns.m}
\end{tcolorbox}
In the next box, we start where we  left off previously, and we pack some more
header information into our listing:
\begin{tcolorbox}[
        skin = octoboxmiddle,
    ]
    \inputminted[
        linenos,
        numbersep=4pt,
        style=solarizedlight,
        firstnumber=last,
        firstline=13,
        lastline=26,
    ]{matlab}{./code/filterChainDesigns.m}
\end{tcolorbox}

Then we describe the target for the FIR filter:
\begin{tcolorbox}[
        skin = octoboxmiddle,
    ]
    \inputminted[
        linenos,
        numbersep=4pt,
        style=solarizedlight,
        firstnumber=29,
        firstline=29,
        lastline=40,
    ]{matlab}{./code/filterChainDesigns.m}
\end{tcolorbox}

After which we start the sript proper by setting up the iteration parameters:
\begin{tcolorbox}[
        skin = octoboxmiddle,
    ]
    \inputminted[
        linenos,
        numbersep=4pt,
        style=solarizedlight,
        firstnumber=43,
        firstline=43,
        lastline=64,
    ]{matlab}{./code/filterChainDesigns.m}
\end{tcolorbox}

We define some data structures to contain the filter objects for further processing:
\begin{tcolorbox}[
        skin = octoboxmiddle,
    ]
    \inputminted[
        linenos,
        numbersep=4pt,
        style=solarizedlight,
        firstnumber=66,
        firstline=66,
        lastline=78,
    ]{matlab}{./code/filterChainDesigns.m}
\end{tcolorbox}

And then we iterate:
\begin{tcolorbox}[
        skin = octoboxlast,
    ]
    \inputminted[
        linenos,
        numbersep=4pt,
        style=solarizedlight,
        firstnumber=80,
        firstline=80,
        %lastline=78,
    ]{matlab}{./code/filterChainDesigns.m}
\end{tcolorbox}

% >>>

\backmatter
\bibliographystyle{IEEEtran}
\bibliography{chunks/references}
% Indexing: memman.pdf, pp. 302ff.
\printindex
\end{document}
%^^A vim: foldenable foldcolumn=4 foldmethod=marker foldmarker=<<<,>>>
