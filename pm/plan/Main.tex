\RequirePackage{snapshot}
\documentclass[a4paper,oneside]{alpenspecs/alpenspecs}
% <<< Preamble
\hexfalse
\paperfalse
%https://tex.stackexchange.com/a/210456/131649
\renewcommand\partnumberlinebox[2]{#2\hspace{2em}}
\usetikzlibrary{positioning}
\tcbuselibrary{breakable}
\tcbset{shield externalize}
\makeindex
% >>>
\begin{document}
\begin{titlingpage} % <<<
    \fullhexpage{q1}{q0}
    \flushright\sffamily

    \vspace*{5em}
    \Huge\bfseries{Red Pitaya}\\[1ex]
    \Large\mdseries{Specifications}\\[3ex]

    \normalsize\mdseries

    \vfill
    Raphael Frey\\
    Noah H\"usser\\[3ex]

    \vspace{5em}

    \today\\
    Version 0.0.1
\end{titlingpage} % >>>

\frontmatter % <<<
% https://en.wikipedia.org/wiki/Edition_notice
\tableofcontents*
%\clearpage
%\listoffigures*
%\clearpage
%\listoftables*
%\clearpage
% >>>

\mainmatter

\chapter{Work Packages} % <<< ------------------------------------------------ %
\label{ch:wpac}
% ---------------------------------------------------------------------------- %

        %wpac:
        %{Start Date}
        %{End Date}
        %{Hours}
        %{Ancestors}
        %{Descendants}
        %{Assignee}
        %{Description}

\section{Filter Design}
\label{sec:filters}

Contains the  work packages  relating to  filter design  in Matlab  and filter
implementation in the FPGA tool chain.

\subsection{Filter Research}
\label{subsec:filter:research}

\wpac
     {}
     {}
     {}
     {None}
     {}
     {Raphael Frey}
     {%
         Research the digital filter technologies which will be needed for this
         project. In particular, this includes FIR and CIC filters, since Xilinx
         provide predefined blocks for these filters in their toolchain.

         Besides the general knowledge on digital filters, the Xilinx toolchain
         must be researched in order to understand the FIR and CIC filter blocks
         and allow their usage.
     }

\subsection{Matlab Scripts for Filter Design}
\label{subsec:filter:matlab}

\wpac
     {}
     {}
     {}
     {None}
     {}
     {Raphael Frey}
     {%
         Matlab scripts which design various filter chains. These consist of one
         or several dispatcher scripts where the filter chains are specified in
         terms of their frequency band properties, and scripts which actually
         design the filters according to these specifications.

         Specifically, scripts for generating CIC filters and their compensation
         filters, as well as FIR filters are needed. For FIR filters, the resulting
         coefficients are to be saved in files so that they can be loaded by the
         Xilinx tool chain.

         If possible Matlab's parallelism should be exploited to reduce filter
         design times.
     }

\subsection{TCL Scripts for Filter Evaluation}
\label{subsec:filter:tcl}

\wpac
     {}
     {}
     {}
     {None}
     {}
     {Raphael Frey}
     {%
        In order to assess the resource usage of the filter chains which are
        designed by Matlab, the respective filter blocks (CIC, FIR) need to be
        implemented in Vivado and a bitstream must be compiled.

        Since the number of filters generated by package~\ref{subsec:filter:matlab}
        can be very large (dozens or even hundreds of filters), this process must be automated
        to be of any use. For this, TCL scripts are used.

        For FIR filters, the scripts load the coefficient files which have been
        generated by Matlab.

        Vivado will  generate usage  reports which  can then  be automatically
        post-processed.
     }


\subsection{Documentation}
\label{subsec:filter:doc}

\wpac
     {}
     {}
     {}
     {None}
     {}
     {Raphael Frey}
     {%
         Documentation  for the  filter design  tool chain. The  documentation
         should be sufficiently detailed so that the tool chain can be used by
         a  person  who wishes  to  compile  a  new bitstream  with  different
         filters.
     }


\section{Documentation}
\label{sec:docs}

\subsection{Disposition}
\wpac
     {}
     {}
     {}
     {None}
     {}
     {Noah H\"usser}
     {%
        A general outline of the thesis document.%
     }

\subsection{Report}
\wpac
     {}
     {}
     {}
     {None}
     {}
     {Raphael Frey, Noah H\"usser}
     {%
        The actual thesis document.%
     }


\section{Firmware}
\label{sec:firmware}

\subsection{Linux}
\label{subsec:fw:linux}

\wpac
     {}
     {}
     {}
     {None}
     {}
     {Noah H\"usser}
     {%
        Boot an Ubuntu Linux onto the Red Pitaya.%
        The target here is to have a ARM Linux distribution which boots fine on the RedPitaya.
        The official sources from the RedPitaya project should be used as they contain a lot of patches for the RedPitaya hardware.
        A standalone toolchain has to be developped as the compiled versions do not contain the right device tree (DT) and board support package (BSP).
        Compiling in the right DT and BSP is not part of this task.
     }

\subsection{Server Application}
\label{subsec:fw:server}

\subsubsection{Design Decisions}
\label{subsubsec:fw:server:design-decisions}
\wpac
     {}
     {}
     {}
     {None}
     {}
     {Noah H\"usser}
     {%
         It has to be determined what technology should be used to provide the server side of the data transmission.
         The server needs to be able to perform IOCTL calls and to serve data with the chosen protocol over the network. It has to run on the arm linux and shouldn't have too many dependencies.
         A C-like language will most likely serve best since it's close to the kernel.
     }

\subsubsection{Server Application}
\label{subsubsec:fw:server:server}
\wpac
     {}
     {}
     {}
     {None}
     {}
     {Noah H\"usser}
     {%
         A server application has to be written that reads data from the Logger and transmits it over the network.
         It needs to be able to configure the logger via RPCs that are mapped to IOCTLs.
         It should read data from /dev/logger which is presented by the kernel module.
     }

\subsubsection{Documentation}
\label{subsubsec:fw:server:docs}
\wpac
     {}
     {}
     {}
     {None}
     {}
     {Raphael Frey, Noah H\"usser}
     {%
         Documentation for the server application build process.
     }

\subsection{FPGA}
\label{subsec:fw:fpga}

\subsubsection{Minimal Working Example}
\label{subsubsec:fw:fpga:mwe}
\wpac
     {}
     {}
     {}
     {None}
     {}
     {Noah H\"usser}
     {%
         Get a minimal working example project running on the Red Pitaya.

         This requires importing the cores from Pavel Denim's project as
         well as compiling the Linux for the Red Pitaya.

         Correct functionality of the Red Pitaya hardware, particularly the
         ADC, is to be verified via Anton Potochnik's frequency counter.
     }

\subsubsection{Port Zynq Logger}
\label{subsubsec:fw:fpga:logger}
\wpac
     {}
     {}
     {}
     {None}
     {}
     {Noah H\"usser}
     {%
         Port the Zynq Logger to the Red Pitaya. The main challenges will be
         the porting of its interface (for which a block \code{axis2datalanes}
         is developed), as well as understanding and properly implementing the
         device tree and the kernel module which is needed for the Linux OS
         to interface with the logger hardware.
     }

\subsubsection{Filter Chains}
\label{subsubsec:fw:fpga:filters}
\wpac
     {}
     {}
     {}
     {None}
     {}
     {Raphael Frey}
     {%
         Implement the filter chains as designed in Matlab on the FPGA.

         This requires correct functionality of the FIR and CIC filter
         blocks.
     }


\section{Validation}
\label{sec:validation}

\subsection{Build Process}
\label{subsec:validation:build}
\wpac
     {}
     {}
     {}
     {None}
     {}
     {Raphael Frey}
     {%
         Build the entire project (Linux, bitstream), flash
         result onto the Red Pitaya and verify correct functionality.
     }

\section{Frontend}
\label{sec:frontend}

\subsection{Techology Research}
\label{subsec:frontend:}
\wpac
     {}
     {}
     {}
     {None}
     {}
     {Noah Hüsser}
     {%
         Research the possibilities to design and implement a nice frontend for the RedPitaya recording system.
         The RedPitaya Project has a built-in webinterface which allows the display of signals and rudimentary calculations.
         Furthermore Prof. Gut has implemented a spectrum analyzer in Java which interfaces with the RedPitaya.
         Both approaches are feasible and should be evaluated properly.
         Furthermore it has to be evaluated how the data should be transferred to the frontend.
         This descision correlates a lot with the selection of a programming language since e.g. web technologies do not support UDP.
         Finally, existing libraries have to examined very carefully. There is a lot of libraries around data transmission and GUI design, but not all of them are feasible.
     }

\subsection{Implementation of a basic Plotter}
\label{subsec:frontend:}
\wpac
     {}
     {}
     {}
     {Techology Research}
     {}
     {Noah Hüsser}
     {%
         At first a simple plotter will be implemented. It should not do more than plot a given vector of data points on a canvas.
         The plotting should be done performantly at 60 frames per second not being dependant on the size of the data vector.
         Of course more data will slow down the plotting, but it should perform so well that the size of vectors up to 64 kilosamples do plot nicely.
         For this task it is recommended to use existing libraries which make use of the GPU such as OpenGL.
     }

\subsection{Implementation of a basic Receiver}
\label{subsec:frontend:}
\wpac
     {}
     {}
     {}
     {Techology Research, TODO: server}
     {}
     {Noah Hüsser}
     {%
         A simple receiver which receives recorded samples over the network should be created.
         For this task a simple emmitter which emmits test samples without actually recording anything should be implemented.
         In further tasks it can be used conveniently without the need of a running RedPitaya board.
         The receiver should simply receive samples as packets with lengths of powers of two over the network.
         Again, a good, performant and publicly accepted library should be used to reduce workload and ensure reliability.
     }

\subsection{Combining the Plotter and the Receiver}
\label{subsec:frontend:}
\wpac
     {}
     {}
     {}
     {Implementation of a basic Plotter, Implementation of a basic Receiver}
     {}
     {Noah Hüsser}
     {%
         The plotter and the receiver should be combined to display vecors received over the network.
         This should happen fluently without any delays.
     }

\subsection{Setting a Trigger on the Logger Core}
\label{subsec:frontend:}
\wpac
     {}
     {}
     {}
     {Combining the Plotter and the Receiver}
     {}
     {Noah Hüsser}
     {%
         The application should have a possibility to set a trigger type for any channel with the possibility to do this using a GUI.
     }

\subsection{Implement Proper Scaling}
\label{subsec:frontend:}
\wpac
     {}
     {}
     {}
     {Setting a Trigger on the Logger Core}
     {}
     {Noah Hüsser}
     {%
         The GUI should not only plot a qualitatively correct signal but also show it's quantities.
         A grid should be programmed into the GUI which can be used to read metrics of a signal. A panel on the GUI should display the current grid size.
         It should be possible to scale signals using the mouse or the GUI. Grids should adjust with the current scale.
     }

\subsection{Implement Trigger Modes}
\label{subsec:frontend:}
\wpac
     {}
     {}
     {}
     {Combining the Plotter and the Receiver}
     {}
     {Noah Hüsser}
     {%
         It should be possible to use the scope application in \textit{normal}, \textit{auto}, and \textit{single} mode. Those modes should behave as follows:
         \begin{tabular}{l l}
            \textit{normal} & the server sends a packet when a trigger was fired and repeats this procedure \\
            \textit{auto} & the server sends a packet when a trigger was fired or a timeout has been hit and repeats this procedure \\
            \textit{single} & the server sends a packet after a first trigger and does not repeat this procedure
         \end{tabular}
     }

\subsection{Implement an FFT}
\label{subsec:frontend:}
\wpac
     {}
     {}
     {}
     {None}
     {}
     {Noah Hüsser}
     {%
         An FFT should be calculated and displayed live.
     }

\subsection{Implement Power Measuremenets}
\label{subsec:frontend:}
\wpac
     {}
     {}
     {}
     {None}
     {}
     {Noah Hüsser}
     {%
         Calculate the power in the signal.
         It has to be possible to calculate the power between two markers to limit the calulation on a certain part of the signal.
     }

\subsection{Implement SNR Calculation}
\label{subsec:frontend:}
\wpac
     {}
     {}
     {}
     {None}
     {}
     {Noah Hüsser}
     {%
         The SNR of the signal between two markers has to be calculated automatically.
         As a reference use the Java applicaion of Prof. Gut.
     }

\subsection{Implement THD Calculation}
\label{subsec:frontend:}
\wpac
     {}
     {}
     {}
     {None}
     {}
     {Noah Hüsser}
     {%
         The THD of the signal spectrum has to be calculated automatically.
         As a reference use the Java application of Prof. Gut.
     }

\subsection{Implement Dual Channel Possibilities}
\label{subsec:frontend:}
\wpac
     {}
     {}
     {}
     {None}
     {}
     {Noah Hüsser}
     {%
         The entire transmission and plotting of all the signals should be implemented for dual channel capabilities.
         The FPGA code supports up to eight channels whilst only supplying two to the server since the RedPitaya board only supports two physical channels.
     }

% >>>

\backmatter
\end{document}
%^^A vim: foldenable foldcolumn=4 foldmethod=marker foldmarker=<<<,>>>
