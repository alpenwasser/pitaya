\RequirePackage{snapshot}
\documentclass[a4paper,oneside]{alpenspecs/alpenspecs}
% <<< Preamble
\hexfalse
\paperfalse
%https://tex.stackexchange.com/a/210456/131649
\renewcommand\partnumberlinebox[2]{#2\hspace{2em}}
\usetikzlibrary{positioning}
\tcbuselibrary{breakable}
\tcbset{shield externalize}
\makeindex
% >>>
\begin{document}
\begin{titlingpage} % <<<
    \fullhexpage{q1}{q0}
    \flushright\sffamily

    \vspace*{5em}
    \Huge\bfseries{Red Pitaya}\\[1ex]
    \Large\mdseries{Specifications}\\[3ex]

    \normalsize\mdseries

    \vfill
    Raphael Frey\\
    Noah H\"usser\\[3ex]

    \vspace{5em}

    \today\\
    Version 0.0.1
\end{titlingpage} % >>>

\frontmatter % <<<
% https://en.wikipedia.org/wiki/Edition_notice
\tableofcontents*
%\clearpage
%\listoffigures*
%\clearpage
%\listoftables*
%\clearpage
% >>>

\mainmatter

\chapter{Work Packages} % <<< ------------------------------------------------ %
\label{ch:wpac}
% ---------------------------------------------------------------------------- %

        %wpac:
        %{Start Date}
        %{End Date}
        %{Hours}
        %{Ancestors}
        %{Descendants}
        %{Assignee}
        %{Description}

\section{Filter Design}
\label{sec:filters}

Contains the  work packages  relating to  filter design  in Matlab  and filter
implementation in the FPGA tool chain.

\subsection{Filter Research}
\label{subsec:filter:research}

\wpac
     {}
     {}
     {}
     {None}
     {}
     {Raphael Frey}
     {%
         Research digital the filter technologies which will be needed for this
         project. In particular, this includes FIR and CIC filters, since Xilinx
         provide predefined blocks for these filters in their toolchain.

         Besides the general knowledge on digital filters, the Xilinx toolchain
         must be researched in order to understand the FIR and CIC filter blocks
         and allow their usage.
     }

\subsection{Matlab Scripts for Filter Design}
\label{subsec:filter:matlab}

\wpac
     {}
     {}
     {}
     {None}
     {}
     {Raphael Frey}
     {%
         Matlab scripts which design various filter chains. These consist of one
         or several dispatcher scripts where the filter chains are specified in
         terms of their frequency band properties, and scripts which actually
         design the filters according to these specifications.

         Specifically, scripts for generating CIC filters and their compensation
         filters, as well as FIR filters are needed. For FIR filters, the resulting
         coefficients are to be saved in files so that they can be loaded by the
         Xilinx tool chain.

         If possible Matlab's parallelism should be exploited to reduce filter
         design times.
     }

\subsection{TCL Scripts for Filter Evaluation}
\label{subsec:filter:tcl}

\wpac
     {}
     {}
     {}
     {None}
     {}
     {Raphael Frey}
     {%
        In order to assess the resource usage of the filter chains which are
        designed by Matlab, the respective filter blocks (CIC, FIR) need to be
        implemented in Vivado and a bitstream must be compiled.

        Since the number of filters generated by package~\ref{sec:filter:matlab}
        can be very large (dozens or even hundreds), this process must be automated
        to be of any use. For this, TCL scripts are used.

        For FIR filters, the scripts load the coefficient files which have been
        generated by Matlab.

        Vivado will  generate usage  reports which  can then  be automatically
        post-processed.
     }


\subsection{Documentation}
\label{subsec:filter:doc}

\wpac
     {}
     {}
     {}
     {None}
     {}
     {Raphael Frey}
     {%
         Documentation  for the  filter design  tool chain. The  documentation
         should be sufficiently detailed so that the tool chain can be used by
         a  person  who wishes  to  compile  a  new bitstream  with  different
         filters.
     }


\section{Documentation}
\label{sec:docs}

\subsection{Disposition}
\wpac
     {}
     {}
     {}
     {None}
     {}
     {Noah H\"usser}
     {%
        A general outline of the thesis document.%
     }

\subsection{Report}
\wpac
     {}
     {}
     {}
     {None}
     {}
     {Raphael Frey, Noah H\"usser}
     {%
        The actual thesis document.%
     }


\section{Firmware}
\label{sec:firmware}

\subsection{Linux}
\label{subsec:fw:linux}

\wpac
     {}
     {}
     {}
     {None}
     {}
     {Noah H\"usser}
     {%
        Load Ubuntu Linux onto the Red Pitaya.%
     }

\subsection{Server Application}
\label{subsec:fw:server}

\subsubsection{Design Decisions}
\label{subsubsec:fw:server:design-decisions}
\wpac
     {}
     {}
     {}
     {None}
     {}
     {Noah H\"usser}
     {%
         Design decisions for server application.
     }

\subsubsection{Server Application}
\label{subsubsec:fw:server:server}
\wpac
     {}
     {}
     {}
     {None}
     {}
     {Noah H\"usser}
     {%
         The server application itself.%
     }

\subsubsection{External Libraries}
\label{subsubsec:fw:server:libs}
\wpac
     {}
     {}
     {}
     {None}
     {}
     {Noah H\"usser}
     {%
         A build infrastructure which allows for the compilation of the
         external libraries which are needed for the server application.

         This includes \code{uWebSockets}, \code{zlib} and \code{OpenSSL}.
     }

\subsubsection{Documentation}
\label{subsubsec:fw:server:docs}
\wpac
     {}
     {}
     {}
     {None}
     {}
     {Raphael Frey, Noah H\"usser}
     {%
         Documentation for the server application build process.
     }

\subsection{FPGA}
\label{subsec:fw:fpga}

\subsubsection{Minimal Working Example}
\label{subsubsec:fw:fpga:mwe}
\wpac
     {}
     {}
     {}
     {None}
     {}
     {Noah H\"usser}
     {%
         Get a minimal working example project running on the Red Pitaya.

         This requires importing the cores from Pavel Denim's project as
         well as compiling the Linux for the Red Pitaya.

         Correct functionality of the Red Pitaya hardware, particularly the
         ADC, is to be verified via Anton Potochnik's frequency counter.
     }

\subsubsection{Port Zynq Logger}
\label{subsubsec:fw:fpga:logger}
\wpac
     {}
     {}
     {}
     {None}
     {}
     {Noah H\"usser}
     {%
         Port the Zynq Logger to the Red Pitaya. The main challenges will be
         the porting of its interface (for which a block \code{axis2datalanes}
         is developed), as well as understanding and properly implementing the
         device tree and the kernel module which is needed for the Linux OS
         to interface with the logger hardware.
     }

\subsubsection{Filter Chains}
\label{subsubsec:fw:fpga:filters}
\wpac
     {}
     {}
     {}
     {None}
     {}
     {Raphael Frey}
     {%
         Implement the filter chains as designed in Matlab on the FPGA.

         This requires correct functionality of the FIR and CIC filter
         blocks.
     }


\section{Validation}
\label{sec:validation}

\subsubsection{Build Process}
\label{subsec:validation:build}
\wpac
     {}
     {}
     {}
     {None}
     {}
     {Raphael Frey}
     {%
         Build the entire project (Linux, bitstream), flash
         result onto the Red Pitaya and verify correct functionality.
     }

\section{Frontend}
\label{sec:frontend}

\subsubsection{Techology Research}
\label{subsec:frontend:}
\wpac
     {}
     {}
     {}
     {None}
     {}
     {Noah Hüsser}
     {%
         Research the possibilities to design and implement a nice frontend for the RedPitaya recording system.
         The RedPitaya Project has a built-in webinterface which allows the display of signals and rudimentary calculations.
         Furthermore Prof. Gut has implemented a spectrum analyzer in Java which interfaces with the RedPitaya.
         Both approaches are feasible and should be evaluated properly.
         Furthermore it has to be evaluated how the data should be transferred to the frontend.
         This descision correlates a lot with the selection of a programming language since e.g. web technologies do not support UDP.
         Finally, existing libraries have to examined very carefully. There is a lot of libraries around data transmission and GUI design, but not all of them are feasible.
     }

\subsubsection{Implementation of a basic Plotter}
\label{subsec:frontend:}
\wpac
     {}
     {}
     {}
     {Techology Research}
     {}
     {Noah Hüsser}
     {%
         At first a simple plotter will be implemented. It should not do more than plot a given vector of data points on a canvas.
         The plotting should be done performantly at 60 frames per second not being dependant on the size of the data vector.
         Of course more data will slow down the plotting, but it should perform so well that the size of vectors up to 64 kilosamples do plot nicely.
         For this task it is recommended to use existing libraries which make use of the GPU such as OpenGL.
     }

\subsubsection{Implementation of a basic Receiver}
\label{subsec:frontend:}
\wpac
     {}
     {}
     {}
     {Techology Research, TODO: server}
     {}
     {Noah Hüsser}
     {%
         A simple receiver which receives recorded samples over the network should be created.
         For this task a simple emmitter which emmits test samples without actually recording anything should be implemented.
         In further tasks it can be used conveniently without the need of a running RedPitaya board.
         The receiver should simply receive samples as packets with lengths of powers of two over the network.
         Again, a good, performant and publicly accepted library should be used to reduce workload and ensure reliability.
     }

\subsubsection{Combining the Plotter and the Receiver}
\label{subsec:frontend:}
\wpac
     {}
     {}
     {}
     {Implementation of a basic Plotter, Implementation of a basic Receiver}
     {}
     {Noah Hüsser}
     {%
         The plotter and the receiver should be combined to display vecors received over the network.
         This should happen fluently without any delays.
     }

\subsubsection{Setting a Trigger on the Logger Core}
\label{subsec:frontend:}
\wpac
     {}
     {}
     {}
     {Combining the Plotter and the Receiver}
     {}
     {Noah Hüsser}
     {%
         The application should have a possibility to set a trigger type for any channel with the possibility to do this using a GUI.
     }

\subsubsection{Implement Proper Scaling}
\label{subsec:frontend:}
\wpac
     {}
     {}
     {}
     {Setting a Trigger on the Logger Core}
     {}
     {Noah Hüsser}
     {%
         The GUI should not only plot a qualitatively correct signal but also show it's quantities.
         A grid should be programmed into the GUI which can be used to read metrics of a signal. A panel on the GUI should display the current grid size.
         It should be possible to scale signals using the mouse or the GUI. Grids should adjust with the current scale.
     }

\subsubsection{Implement Trigger Modes}
\label{subsec:frontend:}
\wpac
     {}
     {}
     {}
     {Combining the Plotter and the Receiver}
     {}
     {Noah Hüsser}
     {%
         It should be possible to use the scope application in \textit{normal}, \textit{auto}, and \textit{single} mode.
         Those modes do as follows:
         \begin{tabular}{l l}
            \textit{normal} & the server sends a packet when a trigger was fired and repeats this procedure \\
            \textit{auto} & the server sends a packet when a trigger was fired or a timeout has been hit and repeats this procedure \\
            \textit{single} & the server sends a packet after a first trigger and does not repeat this procedure
         \end{tabular}
     }

 \subsubsection{}
\label{subsec:frontend:}
\wpac
     {}
     {}
     {}
     {None}
     {}
     {Noah Hüsser}
     {%
         
     }

\subsubsection{}
\label{subsec:frontend:}
\wpac
     {}
     {}
     {}
     {None}
     {}
     {Noah Hüsser}
     {%
         
     }

\subsubsection{}
\label{subsec:frontend:}
\wpac
     {}
     {}
     {}
     {None}
     {}
     {Noah Hüsser}
     {%
         
     }

\subsubsection{}
\label{subsec:frontend:}
\wpac
     {}
     {}
     {}
     {None}
     {}
     {Noah Hüsser}
     {%
         
     }

% >>>

\backmatter
\end{document}
%^^A vim: foldenable foldcolumn=4 foldmethod=marker foldmarker=<<<,>>>
